# 자동차 저장 구현(개선)

# `batchUpdate` 제거

DB에 접근해 쿼리를 전달하는 데는 꽤 큰 시간이 걸린다.

그래서 `batchUpdate` 사용이 한번에 많이 삽입한다는 면에서 의미있는 최적화라고 생각했다.

하지만 `JdbcTemplate#batchUpdate` 메서드는 삽입한 데이터들의 Id를 반환하지 않는다.

따라서 Id가 필요한 상황에서 사용하기 부적절하다.

게다가 쿼리 전송량이 적으므로 의미가 크지 않다고 생각해 `for` 문과 `update` 로 대체했다.

# Dao 저장 메서드의 Id 반환

- 현재 요구사항은 결과 저장뿐이므로 Id 반환은 불필요하다.
- 게임 생성/완료를 모두 DB에 기록한다면, 필요하다.
    - 즉, 객체 라이프사이클과 DB 데이터의 라이프사이클이 같아질 때 필요하다.
    - DB에 저장된 게임을 갱신해야하기 때문이다.

# GameDao 하나로 모든 DB 접근

처음 의도는 `GameDao`, `CarDao` 등 여러 DAO를 만들고 `GameService` 에서 조립해 하나의 비즈니스 로직을 완성하는 것이엇다.

하지만 `Game` 객체는 다수의 `Car` 를 가진다.

따라서 `Game` 객체를 저장했는데, 내부의 `Car`가 저장되지 않는 어색한 상황이 생길 수 있다. (예측하기 어렵다)

그러므로 우선 `Game` 객체를 전달하고, 내부의 `Car` 도 함께 저장하게 구현했다.

# SimpleJdbcInsert 도입

- 사용한 인스턴스의 설정을 바꾸면 안된다.
    - `usingColumns`, `withTableName`, `usingGeneratedKeyColumns` 등
- `usingColumns` 로 사용할 컬럼만 지정할 수 있다.
- `MapSqlParameterSource` 로 value를 가독성 좋게 지정할 수 있다.
- `executeAndReturnKey` 로 생성된 Id(Key)를 쉽게 얻을 수 있다.

# DAO 분리

- 처음 `GameDao` 를 만들때만 해도 DAO와 도메인 클래스가 1:1 관계라고 생각했다.
  하지만 지금은 도메인과 1:1 이 아니라, **테이블과 1:1**이라고 표현하는 편이 더 알맞다고 생각한다.
- DAO 메서드의 인자로 도메인을 직접 사용하기보다는, 원시값에 가까운 값으로 전달해주는 편이 나았다.
    - 의존성 제거 → 도메인의 변경이 DAO로 전파되지 않는다.
    - (==) 도메인-스키마 간 분리
- `SimpleJdbcInsert`를 사용할 때, 설정을 변경할 필요가 없으므로 인스턴스를 하나로 유지할 수 있다.

## DAO 메서드 인자의 `Car` 를 DTO로 대체

- 장점:
    - 메서드 노출(변경)을 막는다.
    - 불필요한 정보를 노출시키지 않는다.
    - 의존성 제거 → 변경 유리
- 맹점:
    - 현재 코드(`Map<Car, Integer>`)에서 객체의 식별이 불가능해진다.
- 해결책
    - ~~name으로 식별~~
        - ‘이름’은 비즈니스 로직 변화에 굉장히 민감하다.
        - 성능상도 숫자 Id 간의 비교보다 느릴 것이다.
        - 따라서 식별자로 쓰기에 적절하지 않다.
    - List 대신, 한 개씩 삽입한다.
        - 객체 - Id의 관계는 service에서 관리한다.(`Map<>`)